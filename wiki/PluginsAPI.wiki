#summary VLCShares plugins system information
#labels Phase-Implementation

= Introduction =

This document talks about the plugin system of VLCShares. This infos are aimed for developer.

= System Architecture =

VLCShares is built upon [http://framework.zend.com/ ZendFramework]. Understanding of the functioning of the framework is a recommended prerequisite to better understand how VLCShares works.

VLCShares follows the MVC Pattern and integrates an independent Plugins System. Main controllers follow the baselines of ZendFramework (so, they are placed inside _application/controllers/_ folder) and follow ZendFramework name rules.

Standard main controllers are:
  * *IndexController*: index controller. Redirect the application flow to Management interface or Browse interface and provides collections index page.
  * *ManageController*: management page controller. Dashboard and configs panels are provided by this controller. 
  * *BrowseController*: manage the browse/stream functionality. The main work of this plugin is to reassemble resource returned by plugins.
  * *ControlsController*: provides functionality for controls vlc's streams.
  * *TestController*: execute system test and provides results.
  * *ErrorController*: display error information
  * *ConfigController*: provide a way to manage lazy plugins configurations without the need of create a plugin management interface for each plugin.
  * *InstallerController*: execute initial configuration of VLCShares

The following scheme reproduce the transactions between controlles and pages while in browse and reproduction mode

|| http://vlc-shares.googlecode.com/svn/wiki/scheme-browse-reproduction.png ||

== Plugins System ==

The core part of plugins system is the Plugin Broker ({{{X_VlcShares_Plugins_Broker}}} class) object. It acts as a container for plugin references and forwards trigger calls to each plugin that is registered for the trigger. This object is bootstrapped by another class ({{{X_VlcShares_Plugins}}}) that has the assignment of create plugin broker, register installed (and active) plugins into the broker, initialize plugins configs and initialize active plugin helpers.
The plugin broker also provides services for register/unregister new plugins on the fly or for plugin retrieval by id or class.
Usage example (can be executed anywhere inside the application):
{{{
$pluginBroker = X_VlcShares_Plugins::broker();
$myPlugin = new My_Plugin_That_Does_Lots_Stuff();

// register on the fly a new plugin
$pluginBroker->register('myPluginId', $myPlugin);

// check if plugin is registered
if ( $pluginBroker->isRegistered('myPluginId') ) {
   // ...and unregister it
   $pluginBroker->unregisterPluginId('myPluginId');
} else {
   // ...or unregister all plugin of class...
   $pluginBroker->unregisterPluginClass('My_Plugin_That_Does_Lots_Stuff');
}

// let's see what is registered now
var_dump($pluginBroker->getPlugins());

// i want a specific plugin by ID
try {
   $anotherPlugin = $pluginBroker->getPlugins('anotherPluginId');
   $anotherPlugin->specificFunctionCall();
} catch (Exception $e) {
   // there isn't the plugin
}

// let's call a trigger function:
// even if there is no gen_afterPluginsInitialized in the class
// the magic function __call trap the call and forward it
// to all plugin registered for that trigger
$pluginBroker->gen_afterPluginsInitialized();

// unregister all plugins
$pluginBroker->unregisterAll();

}}}

The controllers use the plugin broker to trigger functions of registered plugins.

A valid plugin for VLCShares 0.5 must extends the abstract class {{{X_VlcShares_Plugins_Abstract}}}. This abstract class provides basic services for configuration store and retrieval, plugins priorities and a list of implemented and neutral (no interaction or return values) valid trigger functions.
While creating a new plugin you must override one or more triggers and register the plugin for those triggers using the {{{setPriority}}} function.

=== Priority System ===
The priority system is used by the plugin broker to sort plugin calls. If a plugin want to register itself for a trigger, it must use the {{{setPriority}}} function:

{{{
/**
 * Set priority for the trigger 
 * (if priority for a trigger is not setted,
 * the trigger callback will be ignored)
 * @param string $triggerName
 * @param int $priority
 * @return X_VlcShares_Plugins_Abstract
 */
public function setPriority($triggerName, $priority = 50);
}}}

Valid values for {{{$priority}}} are positive integers. _0_ indicates top priority. If two or more plugins register their self for the same trigger with the same priority, they will be sorted by registration order.

=== Standard Interfaces ===

VLCShares provides some standard interface for plugins.
  * {{{X_VlcShares_Plugins_ResolverInterface}}}: data provider plugins should implement this interface for allow others plugin to resolve a decoded and absolute resource location.
  * {{{X_VlcShares_Plugins_ResolverDisplayableInterface}}}: this interface extends {{{X_VlcShares_Plugins_ResolverInterface}}} and ensures that the returned value of {{{resolveLocation}}} function can be displayed by the interface. This interface has been added in VLCShares 0.5.1

=== Inputs and Outputs ===

Input and Outputs of trigger functions are specified in the function comment. However, most of the trigger functions of level1 apis require arrays of page items as output.

Page items are associative arrays with some selected keys. Below there is a list of valid keys

|| *Key* || *Meaning* || *Value type* || *Required* || *Default* ||
|| label || The name of the page item || String || true || no-default ||
|| link || The URL address of the resource that you are describing || URL || true || no-default ||
|| type || The type of resource that you are linking || video | playlist | search || false || playlist ||
|| icon || An icon that will represent the item || String: a path of a file inside the /public/ dir || false || null, but some renderer could have a default ||
|| desc || A short description of the item || String || false || null ||
|| location || The plain location value of the item || String || false || null ||
|| thumb || The location of a thumbnail image || URL || false || null, but some renderer could have a default ||
|| highlight || If the renderer should highlight the item || Boolean || false || false ||

Label and Link keys are mandatory, the others are optional. Any other key type can be used to specified plugin-specific key. It's better if you prepend the plugin-specific keys with a %PLUGIN_CLASS%: namespace to avoid overriding.

This is a pratical example of how to specify a page items array. The item in the example is one of the items returned from the plugin FileSystem for the index/collections page:
{{{
return array(
		array(
			'label' => X_Env::_('p_filesystem_collectionindex'), 
			'link'	=> X_Env::completeUrl(
				$urlHelper->url(
					array(
						'controller' => 'browse',
						'action' => 'share',
						'p' => $this->getId(),
					), 'default', true
				)
			),
			'icon'	=> '/images/filesystem/logo.png',
			'desc'	=> X_Env::_('p_filesystem_collectionindex_desc')
		)
	);
}}}

=== Plugin Preferences ===

Each plugin can have its own preferences or options. Those options are stored inside the database at plugin installation time and will be fetched and inserted in the plugin every time the plugin systems is initialized automatically. Plugins created and registered on the fly through the plugin broker need to be manually initialized.

Inside the plugin scope, options are available through the {{{$this->options}}} class property as a {{{Zend_Config}}} object or through the function:
{{{
/**
 * Return a config key value or the default specified as parameter
 * if the key isn't registered. This function allow
 * keys in dotted notation (key.subkey.subsubkey)
 * @param string $key
 * @param midex $default
 */
public function config($key, $default = null);
}}}

Options available in the plugin scope are read-only. To change config values must be used a proper interface provided by the plugin or the way offered by the ConfigController for lazy plugins.

== Plugins Helpers ==

VLCShares provide a set of plugin helpers for plugins and controllers. Each helper has its own interface and for more information you should read the helper documentation or the inline comments.
The purpose of plugin helpers is to provide common services for all plugins. Each plugin helper is registered agains the plugin helper broker ({{{X_VlcShares_Plugins_Helper_Broker}}} class). A reference to helper broker is available through the {{{X_VlcShares_Plugins::helpers()}}} function or, in the plugin class scope, through the {{{X_VlcShares_Plugins_Abstract::helpers()}}} method. The helper broker allow to register/unregister new helpers on the fly. For more information read the inline comments.

VLCShares has a set of core helpers:

|| *Helper name* || Purpose ||
|| Devices || Provide services for identify the device who made a page request through the user-agent ||
|| FFMpeg || Allow to gain information about a stream, both remote than local ||
|| MediaInfo || Allow to gain information about a local stream only ||
|| Stream || Allow to gain information about a stream, both remote than local, through FFMpeg or MediaInfo. Using this helper you will get the infos and the system will choose the best adapter (FFMpeg or MediaInfo) for the stream ||
|| GSpot || This helper is planned for local files analysis, but not implemented yet ||


== How to create a new Plugin ==

= Generic triggers =

=== gen_afterPluginsInitialized ===

{{{
/**
 * Triggered after plugins system has been initialized
 * Plugins that offer plugin-blacklisting services should hook here
 * This trigger allow to unregister plugins
 * @param X_VlcShares_Plugins_Broker $broker
 */
public function gen_afterPluginsInitialized(X_VlcShares_Plugins_Broker $broker) {}
}}}

=== gen_beforePageBuild ===

{{{
/**
 * Triggered before page is generated (and action is called)
 * All plugin for request filtering should hook here
 * This trigger allow plugin to decided if request should be executed
 * or redirected (altering router options). Example:
 * if user not autenticated: --> redirect to login
 * if planets are aligned: --> redirect to url/page
 */
public function gen_beforePageBuild(Zend_Controller_Action $controller ) {}
}}}

=== gen_afterPageBuild ===

{{{
/**
 * Triggered after all links are generated
 * All page renderer plugin should hook here
 * This trigger allow plugin to decide how render
 * the page.
 * The rendering should be device based. For example
 * after sniffing user agent
 * if wiimc: --> output should be plx format
 * if android: --> output should be html mobile format (low res screen)
 * if pc: --> full size output
 * 
 * @param array $items items in the page
 * @param Zend_Controller_Action $controller the controller who handle the request
 */
}}}

=== gen_beforeInit ===

{{{
/**
 * Triggered at the top of X_Controller_Action::init(),
 * before controller properties init
 * All resource initializer plugin should hook here
 * @param Zend_Controller_Action $controller
 */
public function gen_beforeInit(Zend_Controller_Action $controller) {}
}}}

=== gen_afterInit ===

{{{
/**
 * Triggered at the end of X_Controller_Action::init(),
 * after controller properties init
 * Plugins who check resource initialization should hook here
 * @param Zend_Controller_Action $controller
 */
public function gen_afterInit(Zend_Controller_Action $controller) {}
}}}

=== gen_preProviderSelection ===

{{{
/**
 * Triggered before provider check and selection
 * Allow plugin to change provider and/or params
 * This should be usefull for blacklisting plugin
 * @param $controller
 */
public function gen_preProviderSelection(Zend_Controller_Action $controller) {}
}}}

= Level 1 APIs =

== Page: Index/Collections ==

=== preGetCollectionsItems ===

{{{
/**
 * Return items that should be added at the beginning of the list
 * This hook can also used for redirect application flow
 * 
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function preGetCollectionsItems(Zend_Controller_Action $controller) {}
}}}

=== getCollectionsItems ===

{{{
/**
 * Return items that should be added in collection list
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array 
 */
public function getCollectionsItems(Zend_Controller_Action $controller) {}
}}}

=== postGetCollectionsItems ===

{{{
/**
 * Return items that should be added at the end of the list
 * This hook can also used for redirect application flow
 * 
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function postGetCollectionsItems(Zend_Controller_Action $controller) {}
}}}

=== filterCollectionsItems ===

{{{
/**
 * Check the item in the collection should be filtered out
 * If return is false, the item will be discarded at 100%
 * If return is true, isn't sure that the item will be added
 * 'cause another plugin can prevent this
 * 
 * Plugins who check per-item acl or blacklist should hook here
 * 
 * @param mixed $item
 * @param Zend_Controller_Action $controller
 * @return boolean true if item is ok, false if item should be discarded
 */
public function filterCollectionsItems($item, Zend_Controller_Action $controller) {}
}}}

== Page: Browse/Share ==

=== preGetShareItems ===

{{{
/**
 * Return items that should be added at the beginning of the list
 * This hook can also used for redirect application flow
 * 
 * @param string $provider id of the plugin that should handle request
 * @param string $location to share
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function preGetShareItems($provider, $location, Zend_Controller_Action $controller) {}
}}}

=== getShareItems ===

{{{
/**
 * Return items that should be added in collection list
 * @param string $provider id of the plugin that should handle request
 * @param string $location to share
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array 
 */
public function getShareItems($provider, $location, Zend_Controller_Action $controller) {}
}}}

=== postGetShareItems ===

{{{
/**
 * Return items that should be added at the end of the list
 * This hook can also used for redirect application flow
 * 
 * @param string $provider id of the plugin that should handle request
 * @param string $location to share
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function postGetShareItems($provider, $location, Zend_Controller_Action $controller) {}
}}}

=== filterShareItems ===

{{{
/**
 * Check the item in the collection should be filtered out
 * If return is false, the item will be discarded at 100%
 * If return is true, isn't sure that the item will be added
 * 'cause another plugin can prevent this
 * 
 * Plugins who check per-item acl or blacklist should hook here
 * 
 * @param mixed $item
 * @param string $provider
 * @param Zend_Controller_Action $controller
 * @return boolean true if item is ok, false if item should be discarded
 */
public function filterShareItems($item, $provider, Zend_Controller_Action $controller) {}
}}}

=== orderShareItems ===

{{{
/**
 * Allow plugin to shuffle/order items
 * Plugin should use $provider to get location real location
 * @param array &$items list of items
 * @param string $provider id of the plugin the handle the request
 * @param Zend_Controller_Action $controller
 */
public function orderShareItems(&$items, $provider, Zend_Controller_Action $controller) {}
}}}

== Page: Browse/Mode ==

=== preGetModeItems ===

{{{
/**
 * Return items that should be added at the beginning of the list
 * This hook can also used for redirect application flow
 * 
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function preGetModeItems($provider, $location, Zend_Controller_Action $controller) {}
}}}

=== getModeItems ===

{{{
/**
 * Return items that should be added in collection list
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array 
 */
public function getModeItems($provider, $location, Zend_Controller_Action $controller) {}
}}}

=== postGetModeItems ===

{{{
/**
 * Return items that should be added at the end of the list
 * This hook can also used for redirect application flow
 * 
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function postGetModeItems($provider, $location, Zend_Controller_Action $controller) {}
}}}

=== filterModeItems ===

{{{
/**
 * Check the item in the collection should be filtered out
 * If return is false, the item will be discarded at 100%
 * If return is true, isn't sure that the item will be added
 * 'cause another plugin can prevent this
 * 
 * Plugins who check per-item acl or blacklist should hook here
 * 
 * @param mixed $item
 * @param string $provider
 * @param Zend_Controller_Action $controller
 * @return boolean true if item is ok, false if item should be discarded
 */
public function filterModeItems($item, $provider, Zend_Controller_Action $controller) {}
}}}

=== orderModeItems ===

{{{
/**
 * Allow plugin to shuffle/order items
 * Plugin should use $provider to get location real location
 * @param array &$items list of items
 * @param string $provider id of the plugin the handle the request
 * @param Zend_Controller_Action $controller
 */
public function orderModeItems(&$items, $provider, Zend_Controller_Action $controller) {}
}}}

== Page: Browse/Selection ==

=== preGetSelectionItems ===

{{{
/**
 * Return items that should be added at the beginning of the list
 * This hook can also used for redirect application flow
 * 
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param string $pid pluginId who serves preferences selection options
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function preGetSelectionItems($provider, $location, $pid, Zend_Controller_Action $controller) {}
}}}

=== getSelectionItems ===

{{{
/**
 * Return items that should be added in collection list
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param string $pid pluginId who serves preferences selection options
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array 
 */
public function getSelectionItems($provider, $location, $pid, Zend_Controller_Action $controller) {}
}}}

=== postGetSelectionItems ===

{{{
/**
 * Return items that should be added at the end of the list
 * This hook can also used for redirect application flow
 * 
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param string $pid pluginId who serves preferences selection options
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function postGetSelectionItems($provider, $location, $pid, Zend_Controller_Action $controller) {}
}}}

=== filterSelectionItems ===

{{{
/**
 * Check the item in the collection should be filtered out
 * If return is false, the item will be discarded at 100%
 * If return is true, isn't sure that the item will be added
 * 'cause another plugin can prevent this
 * 
 * Plugins who check per-item acl or blacklist should hook here
 * 
 * @param mixed $item
 * @param string $provider
 * @param string $pid pluginId who serves preferences selection options
 * @param Zend_Controller_Action $controller
 * @return boolean true if item is ok, false if item should be discarded
 */
public function filterSelectionItems($item, $provider, $pid, Zend_Controller_Action $controller) {}
}}}

=== orderSelectionItems ===

{{{
/**
 * Allow plugin to shuffle/order items
 * Plugin should use $provider to get location real location
 * @param array &$items list of items
 * @param string $provider id of the plugin the handle the request
 * @param string $pid pluginId who serves preferences selection options
 * @param Zend_Controller_Action $controller
 */
public function orderSelectionItems(&$items, $provider, $pid, Zend_Controller_Action $controller) {}
}}}

== Page: Browse/Stream ==

=== preGetStreamItems ===

{{{
/**
 * Return items that should be added at the beginning of the list
 * This hook can also used for redirect application flow
 * 
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function preGetStreamItems($provider, $location, Zend_Controller_Action $controller) {}
}}}

=== getStreamItems ===

{{{
/**
 * Return items that should be added in collection list
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array 
 */
public function getStreamItems($provider, $location, Zend_Controller_Action $controller) {}
}}}

=== postGetStreamItems ===

{{{
/**
 * Return items that should be added at the end of the list
 * This hook can also used for redirect application flow
 * 
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function postGetStreamItems($provider, $location, Zend_Controller_Action $controller) {}
}}}

=== preRegisterVlcArgs ===

{{{
/**
 * This hook can be used to add low priority args in vlc stack
 * 
 * @param X_Vlc $vlc vlc wrapper object
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param Zend_Controller_Action $controller the controller who handle the request
 */
public function preRegisterVlcArgs(X_Vlc $vlc, $provider, $location, Zend_Controller_Action $controller) {}
}}}

=== registerVlcArgs ===

{{{
/**
 * This hook can be used to add normal priority args in vlc stack
 * 
 * @param X_Vlc $vlc vlc wrapper object
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param Zend_Controller_Action $controller the controller who handle the request
 */
public function registerVlcArgs(X_Vlc $vlc, $provider, $location, Zend_Controller_Action $controller) {}
}}}

=== postRegisterVlcArgs ===

{{{
/**
 * This hook can be used to add top priority args in vlc stack
 * 
 * @param X_Vlc $vlc vlc wrapper object
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param Zend_Controller_Action $controller the controller who handle the request
 */
public function postRegisterVlcArgs(X_Vlc $vlc, $provider, $location, Zend_Controller_Action $controller) {}
}}}

=== preSpawnVlc ===

{{{
/**
 * This hook can be used check vlc status just before
 * spawn is called
 * 
 * @param X_Vlc $vlc vlc wrapper object
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param Zend_Controller_Action $controller the controller who handle the request
 */
public function preSpawnVlc(X_Vlc $vlc, $provider, $location, Zend_Controller_Action $controller) {}
}}}

=== postSpawnVlc ===

{{{
/**
 * This hook can be used to check vlc status just after
 * spawn has been called
 * 
 * @param X_Vlc $vlc vlc wrapper object
 * @param string $provider id of the plugin that should handle request
 * @param string $location to stream
 * @param Zend_Controller_Action $controller the controller who handle the request
 */
public function postSpawnVlc(X_Vlc $vlc, $provider, $location, Zend_Controller_Action $controller) {}
}}}

== Page: Controls/Control ==

=== preGetControlItems ===

{{{
/**
 * Return items that should be added at the beginning of the list
 * 
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function preGetControlItems(Zend_Controller_Action $controller) {}
}}}

=== getControlItems ===

{{{
/**
 * Return items that should be added in collection list
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array 
 */
public function getControlItems(Zend_Controller_Action $controller) {}
}}}

=== postGetControlItems ===

{{{
/**
 * Return items that should be added at the end of the list
 * This hook can also used for redirect application flow
 * 
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function postGetControlItems(Zend_Controller_Action $controller) {}	
}}}

== Page: Controls/Execute ==

=== preGetExecuteItems === 

{{{
/**
 * Return items that should be added at the beginning of the list
 * 
 * @param string $pid
 * @param string $action
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function preGetExecuteItems($pid, $action, Zend_Controller_Action $controller) {}
}}}

=== getExecuteItems ===

{{{
/**
 * Return items that should be added in collection list
 * @param string $pid
 * @param string $action
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array 
 */
public function getExecuteItems($pid, $action, Zend_Controller_Action $controller) {}
}}}

=== postGetExecuteItems ===

{{{
/**
 * Return items that should be added at the end of the list
 * This hook can also used for redirect application flow
 * 
 * @param string $pid
 * @param string $action
 * @param Zend_Controller_Action $controller the controller who handle the request
 * @return array
 */
public function postGetExecuteItems($pid, $action, Zend_Controller_Action $controller) {}	
}}}

=== preExecute ===

{{{
/**
 * This hook is triggered before the command is execute in control action
 * 
 * @param X_Vlc $vlc
 * @param string $pid
 * @param string $action
 * @param Zend_Controller_Action $controller the controller who handle the request
 */
public function preExecute(X_Vlc $vlc, $pid, $action, Zend_Controller_Action $controller) {}
}}}

=== execute ===

{{{
/**
 * Use this hook to execute action on controls controller
 * 
 * @param X_Vlc $vlc
 * @param string $pid
 * @param string $action
 * @param Zend_Controller_Action $controller the controller who handle the request
 */
public function execute(X_Vlc $vlc, $pid, $action, Zend_Controller_Action $controller) {}
}}}

=== postExecute ===

{{{
/**
 * This hook is triggered after the command is execute in control action
 *  
 * @param X_Vlc $vlc
 * @param string $pid
 * @param string $action
 * @param Zend_Controller_Action $controller the controller who handle the request
 */
public function postExecute(X_Vlc $vlc, $pid, $action, Zend_Controller_Action $controller) {}
}}}

= Level 2 APIs =

=== getIndexActionLinks ===

{{{
/**
 * Retrieve first class action links
 * This link will be inserted in a box and shown as a list
 * for shortcuts
 * @param Zend_Controller_Action $this
 * @return array The format of the array should be:
 * 		array(
 * 			array(
 * 				'label' => ITEM LABEL,
 * 				'link'	=> HREF,
 * 				'highlight'	=> true|false,
 * 				'icon'	=> ICON_HREF
 * 			), ...
 * 		)
 */
public function getIndexActionLinks(Zend_Controller_Action $controller) {}
}}}

=== getIndexManageLinks ===

{{{
/**
 * Retrieve second class action links
 * This link will be inserted in a box and shown as a list
 * for shortcuts. First link will be used for box, other links
 * will be added in a list below
 * @param Zend_Controller_Action $this
 * @return array The format of the array should be:
 * 		array(
 * 			array(
 * 				'title' => ITEM TITLE,
 * 				'label' => ITEM LABEL,
 * 				'link'	=> HREF,
 * 				'highlight'	=> true|false,
 * 				'icon'	=> ICON_HREF,
 * 				'subinfos' => array(INFO, INFO, INFO)
 * 			), ...
 * 		)
 */
public function getIndexManageLinks(Zend_Controller_Action $controller) {}
}}}

=== getIndexStatistics ===

{{{
/**
 * Retrieve statistic from plugins
 * @param Zend_Controller_Action $this
 * @return array The format of the array should be:
 * 		array(
 * 			array(
 * 				'title' => ITEM TITLE,
 * 				'label' => ITEM LABEL,
 * 				'stats' => array(INFO, INFO, INFO),
 * 				'provider' => array('controller', 'index', array()) // if provider is setted, stats key is ignored 
 * 			), ...
 * 		)
 */
public function getIndexStatistics(Zend_Controller_Action $controller) {}
}}}

=== getIndexMessages ===

{{{
/**
 * Retrieve messages queue from plugins
 * @param Zend_Controller_Action $this
 * @return array The format of the array should be:
 * 		array(
 * 			array(
 * 				'type' => info|warning|alert|fatal,
 * 				'text' => ITEM TEXT,
 * 			), ...
 * 		)
 */
public function getIndexMessages(Zend_Controller_Action $controller) {}
}}}

=== getIndexNews ===

{{{
/**
 * Retrieve news from plugins
 * @param Zend_Controller_Action $this
 * @return array The format of the array should be:
 * 		array(
 * 			array(
 * 				'title' => ITEM TITLE,
 * 				'text' => HTML STYLIZED TEXT 
 * 			), ...
 * 		)
 */
public function getIndexNews(Zend_Controller_Action $controller) {}
}}}

=== preGetTestItems ===

{{{
/**
 * Allow plugins to insert new tests
 * @param Zend_Config $options
 * @param Zend_Controller_Action $controller
 * @return array format: array(array('testname', 'teststatus', 'testmessage'), array...)
 */
public function preGetTestItems(Zend_Config $options,Zend_Controller_Action $controller) {}
}}}

=== getTestItems ===

{{{
/**
 * Allow plugins to insert new tests
 * @param Zend_Config $options
 * @param Zend_Controller_Action $controller
 * @return array format: array(array('testname', 'teststatus', 'testmessage'), array...)
 */
public function getTestItems(Zend_Config $options,Zend_Controller_Action $controller) {}
}}}

=== postGetTestItems ===

{{{
/**
 * Allow plugins to insert new tests
 * @param Zend_Config $options
 * @param Zend_Controller_Action $controller
 * @return array format: array(array('testname', 'teststatus', 'testmessage'), array...)
 */
public function postGetTestItems(Zend_Config $options,Zend_Controller_Action $controller) {}
}}}

=== prepareConfigElement ===

{{{
/**
 * Allow plugins to prepare own configs (set multioptions, validator, filters...)
 * @param string $section
 * @param string $namespace
 * @param unknown_type $key
 * @param Zend_Form_Element $element
 * @param Zend_Form $form
 * @param Zend_Controller_Action $controller
 */
public function prepareConfigElement($section, $namespace, $key, Zend_Form_Element $element, Zend_Form  $form, Zend_Controller_Action $controller) {}
}}}