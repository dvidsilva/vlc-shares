#summary Tutorial per la creazione di plugin per la versione 0.5.4
#labels Phase-Support

=Premesse=

L'obbiettivo di questo tutorial è quello di mostrare, in maniera pratica, come realizzare un nuovo plugin per VLCShares di tipo DataProvider. I plugin di questo tipo hanno come scopo principale quello di navigare all'interno di un sito web e estrappolarne i contenuti video o audio per renderli utilizzabili dai dispositivi supportati da VLCShares.

<wiki:toc max_depth="6" />

==Prefazione: note preliminari==

Nel tutorial utilizzerò queste convenzioni di base per questioni di comodità:
   * *APACHE_WWW*: indica la directory _DocumentRoot_ utilizzata da Apache. Per Ubuntu, corrisponde alla directory `/var/www/`, per Windows (utilizzando il pacchetto di installazione automatica di VLCShares) corrisponde a `C:\Program Files\VLCShares\www`.
   * *VLCSHARES_BASEDIR*: indica la directory principale di VLCShares (quella che contiene le cartelle `library`, `application`,...). Per Ubuntu corrisponde a `APACHE_WWW/vlc-shares/`, per Windows `APACHE_WWW\vlc-shares\`.
   * *VLCSHARESDEV_BASEDIR*: sarà la directory in cui andremo ad installare la versione di sviluppo di vlc-shares. Per Ubuntu corrisponde a `APACHE_WWW/vlc-shares-dev/`, per Windows `APACHE_WWW\vlc-shares-dev\`.

==Prefazione: prepariamo il NOSTRO ambiente di sviluppo==

In questa fase cercheremo di preparare una installazione di sviluppo di vlc-shares sulla quale poter sviluppare il nostro plugin in maniera diretta. In questo modo potremo lavorare senza dover necessariamente rimuovere e reinstallare ogni versione del plugin per poterne testare le modifiche.

Per poter completare con successo questo tutorial è necessario che siate forniti di qualche semplice strumento di base:
   * *una installazione funzionante di VLCShares.*
   * *un editor di testo o un IDE per php*. Potete usare quello che preferite. Vanno bene sia i semplici editor di testo con il riconoscimento della sintassi php (ad esempio Notepad++ se siete su Windows o GEdit se siete su Linux), che IDE più avanzati che offrono ad esempio auto completamento del codice o altro (ad esempio Zend Studio, Eclipse PDT...)
   * *svn* (se siete su Windows, potete utilizzare TortoiseSVN)
   * *php-cli* (su ubuntu basta installare il pacchetto php5-cli, su Windows dovrebbe essere già compreso nella distribuzione EasyPHP)

Una volta che vi siete procurato il necessario, iniziamo scaricando la versione di sviluppo di vlc-shares.
Utilizzando svn (o TortoiseSVN) dovete eseguire un checkout di una versione di sviluppo all'interno della directory *VLCSHARESDEV_BASEDIR*. Dovete però decidere quale. Avete due scelte a disposizione:
   * potete utilizzare la versione instabile di sviluppo, nel qual caso l'indirizzo di cui effettuare il checkout è il seguente
{{{
http://vlc-shares.googlecode.com/svn/trunk/
}}}
   * oppure potete utilizzare una versione stabile a vostra scelta. Questa guida ha come obbiettivo lo sviluppo di plugin per la versione 0.5.4. Utilizzeremo quindi come indirizzo 
{{{
http://vlc-shares.googlecode.com/svn/tags/0.5.4/
}}} 
*ATTENZIONE:* attualmente la versione 0.5.4 non è stata ancora rilasciata, quindi per ora dovete usare la versione di sviluppo instabile. 

Una volta terminato lo scaricamento, aprile il file *VLCSHARESDEV_BASEDIR*`/public/.htaccess` e aggiungete come prima riga questo testo:

{{{
SetEnv APPLICATION_ENV development
}}}

Fatto questo, posizionate il browser all'indirizzo `http://localhost/vlc-shares-dev/public/` e procedete come in una normale installazione di vlc-shares. E' buona norma non installare alcun genere di plugin opzionale, a meno che non lo riteniate un requisito necessario per il vostro plugin.

Una volta completata l'installazione, aprite una console (per Windows XP: cliccate su Start->esegui e scrivete `cmd.exe`, per Windows Vista/7 cliccate su Start e scrivete direttamente `cmd.exe`).

Posizionatevi tramite la console nella directory *VLCSHARESDEV_BASEDIR*`\scripts\`.
Gli utenti Windows possono farlo scrivendo (chiaramente adattate il percorso in base al vostro caso)

{{{
cd C:\Program Files\VLCShares\www\vlc-shares-dev\scripts\
}}}

Gli utenti Ubuntu possono farlo scrivendo

{{{
cd /var/www/vlc-shares-dev/scripts/
}}}

A questo punto siamo pronti a cominciare.

=Realizzazione=

==Fase 1: scegliamo il nostro obbiettivo==

Come già detto nelle premesse, il plugin che andremo a realizzare è di tipo DataProvider. Questo significa che abbiamo bisogno di un sito target nel quale il nostro plugin dovrà andare a cercare i video. Ho deciso, per questioni di semplicità di realizzazione, di utilizzare il sito `film-stream.tv` in questo esempio.

La struttura del sito è abbastanza semplice, questo schema dovrebbe chiarirla:

{{{
            HOME ---- Ultimi aggiornamenti
             |           |- serie
             |           |- film
             |           |- anime
             |
             |---- FILM ---- A ----- Titolo A1 ---- Megavideo
             |            |- B    |- Titolo A2   |- Megaupload
             |            |- ...  |- ...         |- ...
             |
             |---- ANIME ---- Titolo A1 ---- Puntata [1x01]
             |             |- Titolo A2   |- Puntata [1x02]
             |             |- Titolo B1   |- Puntata [2x01]
             |             |- ...         |- ...
             |
             |---- FILM (sub-ita) ---- Titolo A1 ---- Megavideo
             |                      |- Titolo B1   |- Megaupload
             |                      |- ...         |- ...
             |
             |---- SERIETV ---- Titolo A1 ---- Puntata [1x01]
                             |- Titolo A2   |- Puntata [1x02]
                             |- Titolo B1   |- Puntata [2x01]
                             |- ...         |- ...
    
}}}

==Fase 2: immaginiamo il nostro plugin==

Struttureremo il nostro plugin in modo che sia possibile raggiungere gli indici delle varie tipologie di filmati suddivisi per lettere e che sia anche possibile ottenere gli ultimi aggiornamenti per ogni categoria. Struttureremo i nostri contenuti in questo modo:

{{{

SELEZIONE TIPO -----> SELEZIONE GRUPPO ---> SEL. TITOLO --> SEL. VIDEO
 |- film               |- Ult. Aggior.       |- Tit. 1       |- Vid 1
 |- anime              |- A                  |- Tit. 2       |- Vid 2
 |- film subita        |- B                  |- ...          |- ...
 |- serie tv           |- ...


}}}


I plugin per VLCShares sono molto versatili e possono utilizzare molte componenti diverse: oltre al plugin in se è possibile che in ogni pacchetto di installazione contenga al suo interno molti altri componenti come controller, traduzioni, viste, helper, modelli, tabelle... (per una lista completa è bene dare uno sguardo [PluginsAPI#System_Architecture all'architettura di sistema]). In questo caso specifico il nostro plugin per funzionare ha bisogno soltanto della classe principale e dei file di traduzione. Ogni altro componente è superfluo. Aggiungeremo anche una immagine che rappresenterà il logo del plugin che verrà visualizzata nell'indice delle collezioni (vedremo dopo come).

==Fase 3: prepariamo la struttura del nostro plugin==

Se avete seguito la fase [HowToNewPlugin_0_5_4__IT#Prefazione:_prepariamo_il_NOSTRO_ambiente_di_sviluppo Prefazione: prepariamo il NOSTRO ambiente di sviluppo] dovreste avere una console aperta nella directory *VLCSHARESDEV_BASEDIR*`/scripts/`.

Utilizzando quella console eseguite il comando:

per WINDOWS
{{{
php.bat create-plugin.php -k filmstream -n FilmStream -e plugins,languages,images
}}}

per UBUNTU
{{{
php create-plugin.php -k filmstream -n FilmStream -e plugins,languages,images
}}}

L'esecuzione dello script dovrebbe visualizzare come risultato:
{{{
[EEE] Key already used
}}}

Non c'è niente di cui preoccuparsi: semplicemente vi viene notificato che un plugin che utilizza la stessa chiave è gia presente e che quindi non è possibile utilizzarla. Questo è abbastanza normale visto che il plugin di questo tutorial è incluso all'interno della versione di sviluppo di vlc-shares dalla versione 0.5.4 in poi. Per poter proseguire, dobbiamo quindi rinominare la cartella *VLCSHARESDEV_BASEDIR*`/extra/plugins/filmstream/` in *VLCSHARESDEV_BASEDIR*`/extra/plugins/filmstream-vanilla/`. In questo modo conserverete i file conclusivi che potrete usare come riferimento.

Eseguite nuovamente il comando indicato prima. Questa volta il risultato sarà:
{{{
All done. Bye
}}}

Lo script `create-plugin.php` si prenderà carico di creare la struttura delle directory e la lista dei file necessari per il corretto funzionamento del vostro plugin in base ai parametri che gli avrete indicato.
Lo script accetta questi parametri:

{{{
Usage: create-plugin.php [ options ]
  --key|-k [ <string> ]      Plugin key
  --name|-n [ <string> ]     Plugin name
  --all|-a                   Create all elements
  --ignorekey|-i             Ignore error if the key already exists
  --elements|-e [ <string> ] Create a list of elements (divided by comma). Supported: plugins, helpers, controllers, models, data, views, forms, layouts, languages, images, css, js
--help|-h                  Help -- usage message
}}}

Nel nostro caso specifico, abbiamo indicato allo script di creare la struttura e i file per un plugin che abbia key `filmstream`, nome `FilmStream`, specificando come elementi richiesti `plugins` (crea il file della classe principale del plugin), `languages` (crea i file delle traduzioni), `images` (crea la directory per l'immagine del logo).

Lo script creerà quanto richiesto all'interno della directory *VLCSHARESDEV_BASEDIR*`/extra/plugins/filestream/`.

Questo è quello che verrà creato:

{{{
 extra/plugins/filmstream/
   |-- dev_bootstrap.php
   |-- dev_cleanup.php
   |-- install.sql
   |-- uninstall.sql
   |-- README.txt
   |-- manifest.xml
   |-- languages/
   |     |- X_VlcShares_Plugins_FilmStream.en_GB.ini
   |     |- X_VlcShares_Plugins_FilmStream.it_IT.ini
   |
   |-- public/
   |     |- images/
   |          |- filmstream/
   |
   |-- library/
         |- X/
              |- VlcShares/
                   |- Plugins/
                        |- FilmStream.php
}}}

*ATTENZIONE*: se avete deciso di ignorare la fase di preparazione dell'ambiente di sviluppo è necessario che creiate manualmente questa struttura di file e directory per poter continuare a seguire il tutorial.

Alcuni degli elementi creati dovrebbero essere già noti, così come la struttura delle directory. Nel caso non lo fosse, mi rimando alla lettura della pagina [HowToNewPlugin#Version_0.5.1 sulla creazione dei plugin per la versione 0.5.1] in quanto ancora attuale.

Altri elementi sono stati introdotti dalla versione 0.5.3. I file `dev_bootstrap.php` e `dev_cleanup.php` sono due file utilizzati rispettivamente per l'inizializzazione e la pulizia delle risorse del plugin quando eseguito dall'interno della directory `extra/`.

Normalmente i plugin, per essere inizializzati, necessitano di essere elencati insieme ad alcuni metadati (come la versione e le path dei file), all'interno del database di vlc-shares. Inoltre è necessario che i file siano posizionati in determinati punti del sistema per poter essere utilizzati. Normalmente di questo si occupa il sistema durante l'installazione del plugin utilizzando le informazioni contenute nel file `manifest.xml`. Il problema di questo sistema è che risulta un po' scomodo lavorare sui file di un plugin e poi pacchettizzarlo se è necessario distribuire i file qui e li e dover rimuovere e reinstallare il plugin ogni volta che è necessario apportare delle modifiche e testarle.
Utilizzando il file `dev_bootstrap.php` (dopo averlo modificato a dovere), è possibile indicare al sistema tutte le informazioni necessarie per inizializzare correttamente il plugin.

Come prima fase quindi provvediamo a configurare correttamente il file `dev_bootstrap.php`

Nel nostro caso sarà necessario solo specificare pochi parametri. Modifichiamo l'elenco delle directory e file di cui creare i link 

{{{
/**
 * Insert the needed links
 * Those files or directory will be linked (in linux)
 * or copied (in windows) everytime the application will be executed
 * 
 * Use
 *  APPLICATION_PATH = /vlc-shares/application
 * or
 *  $basePath = the directory where this file is placed
 *  
 * as basepath
 * 
 * Entry format is:
 * 	Real entry path => linked/copied path
 * 
 * Usually language files or image/css/js folders must be setted here
 */
$neededLinks = array(
	//$basePath.'/public/images/myfolder/' => APPLICATION_PATH.'/../public/images/myfolder', // <--- THIS IS AN EXAMPLE FOR FOLDERS
	//$basePath.'/languages/myfile.txt' => APPLICATION_PATH.'/../languages/myfile.txt', // <--- THIS IS AN EXAMPLE FOR FILES
);
}}}

aggiungendo il percorso dei nostri file di lingua e la nostra directory del logo

{{{
$neededLinks = array(
	$basePath.'/public/images/filmstream/' => APPLICATION_PATH.'/../public/images/filmstream', // crea un link della cartella delle immagini
	$basePath.'/languages/X_VlcShares_Plugins_FilmStream.en_GB.ini' => APPLICATION_PATH.'/../languages/X_VlcShares_Plugins_FilmStream.en_GB.ini', // link al file di traduzione
	$basePath.'/languages/X_VlcShares_Plugins_FilmStream.it_IT.ini' => APPLICATION_PATH.'/../languages/X_VlcShares_Plugins_FilmStream.it_IT.ini', // link al file di traduzione
);
}}}

Aggiungiamo poi il percorso al file del plugin all'interno dell'array dei file dei plugin da includere

{{{
/**
 * Plugin class file to include
 * Use
 *  $basePath = the directory where this file is placed
 * as basepath
 */
$pluginsIncludes = array(
	$basePath.'/library/X/VlcShares/Plugins/FilmStream.php',
);
}}}

L'ultima modifica da apportare è quella relativa all'inserimento del nome della classe e della chiave del plugin:

{{{
/**
 * Insert here the pluginKey
 */
$pluginInstance_pluginKey = 'filmstream';

/**
 * Insert here the plugin class
 */
$pluginInstance_pluginClass = 'X_VlcShares_Plugins_FilmStream';
}}}

Una volta eseguito terminato, salviamo il file.

Passiamo quindi ad impostare il file `dev_cleanup.php`. Questo file verrà per ripulire vlc-shares da tutti i file e i riferimenti inseriti dal file `dev_bootstap.php`. La modifica di questo file è abbastanza banale: basta infatti copiare il contenuto dell'array $neededLinks dal file `dev_bootstrap.php`.

{{{
/**
 * Copy here the same value inside the $neededLinks
 * of dev_bootstrap.php file
 */
$neededLinks = array(
	$basePath.'/public/images/filmstream/' => APPLICATION_PATH.'/../public/images/filmstream', // crea un link della cartella delle immagini
	$basePath.'/languages/X_VlcShares_Plugins_FilmStream.en_GB.ini' => APPLICATION_PATH.'/../languages/X_VlcShares_Plugins_FilmStream.en_GB.ini', // link al file di traduzione
	$basePath.'/languages/X_VlcShares_Plugins_FilmStream.it_IT.ini' => APPLICATION_PATH.'/../languages/X_VlcShares_Plugins_FilmStream.it_IT.ini', // link al file di traduzione
);
}}}

Per la compilazione del file `manifest.xml` e le questioni relative a `install.sql` e `uninstall.sql` vi rimando alla guida relativa alla creazione dei plugin per la versione 0.5.1. Potete comunque trovare i file già compilati all'interno della directory `filmstream-vanilla` che avevamo rinominato in precedenza.

==Fase 4: prepariamo la classe del Plugin==

Finalmente è arrivato il momento di cominciare a lavorare sul plugin vero e proprio. Come già descritto nella guida relativa alla versione 0.5.1, il cuore del nostro plugin è la classe `X_VlcShares_Plugins_FilmStream`. Il file che conterrà questa classe è gia stato creato durante la preparazione in *VLCSHARESDEV_BASEDIR*`/extra/plugins/filmstream/library/X/VlcShares/Plugins/FilmStream.php`. Non ci rimane che aprire il file e cominciare a scrivere codice.

Come avrete notato il file esiste, ma è vuoto. Tocca a noi cominciare a riempirlo. 
Partiamo dai concetti di base: ogni plugin per vlc-shares deve estendere la classe `X_VlcShares_Plugins_Abstract`.

Cominciamo quindi definendo la nostra classe:

{{{

<?php 

class X_VlcShares_Plugins_FilmStream extends X_VlcShares_Plugins_Abstract implements X_VlcShares_Plugins_ResolverInterface {

	const VERSION = '0.1';
	const VERSION_CLEAN = '0.1';
	
	function __construct() {
		
	}

	/**
	 * @see X_VlcShares_Plugins_ResolverInterface::getLocation()
	 */
	function resolveLocation($location = null) {
		return false;
	}
	/**
	 * @see X_VlcShares_Plugins_ResolverInterface::getParentLocation()
	 */
	function getParentLocation($location = null) {
		return false;
	}

}

}}}

Come avrete notato, la classe implementa anche un'interfaccia, `X_VlcShares_Plugins_ResolverInterface` appunto. Questa interfaccia definisce due funzioni, nello specifico:

{{{
<?php

/**
 * Plugins that give browse provider services should
 * implement this interface.
 * Other plugin can use this interface for get
 * real location of a resource
 * @author ximarx
 *
 */
interface X_VlcShares_Plugins_ResolverInterface {
	
	/**
	 * Get the real location of a resource from
	 * $location param
	 * @param string $location
	 * @return string resource real location
	 */
	function resolveLocation($location = null);
	/**
	 * Get the parent location string of the current location
	 * value
	 * 
	 * @param $location
	 * @return string resource parent. NULL if there is no parent, false if location is invalid
	 */
	function getParentLocation($location = null);
	
}

}}}

Per poter spiegare il senso di questa interfaccia è necessario spiegare per prima cosa il modo in cui vlc-shares gestisce la navigazione. Durante la navigazione dei contenuti delle collezioni, il plugin che sta gestendo la navigazione (da qui in avanti chiamato provider) valorizza un parametro (la $location) che definisce lo stato della navigazione. Il plugin utilizza la $location per definire di fatto un percorso che identifichi la posizione nella collezione. Il modo con il quale la $location viene definita è responsabilità dei provider, che possono di fatto definire un formato autonomamente. L'unica cosa richiesta ai provider è che dopo essere stato formattato, la $location sia codificata tramite la funzione `X_Env::encode(<string>)`. La decodifica viene gestita autonomamente dal sistema. 

In questo modo però un plugin che non sia il provider non è in grado di determinare lo stato corrente della navigazione. Per ovviare al problema, un provider che vuole permettere a terzi di ottenere informazioni sullo stato può, implementando `X_VlcShares_Plugins_ResolverInterface` offrire un interfaccia con la quale permettere di decodificare la $location in una normale URI fruibile anche al di fuori del provider.

La funzione `getParentLocation` invece permette di risalire allo stato precedente della navigazione partendo dallo stato attuale.

Sebbene non sia obbligatorio implementare l'interfaccia, lo consiglio caldamente perchè sto valutando l'eventualità di renderlo un requisito per le prossime versioni di vlc-shares.


==Fase 5: aggiungiamo il plugin all'indice delle collezioni==

Se avete gia provato vlc-shares, saprete che l'indice delle collezioni è quello mostrato comincia a esplorare i contenuti di vlc-shares. L'indice contiene un riferimento ad ogni provider registrato che è in grado di permettere l'esplorazione di una risorsa.

L'inserimento di un elemento all'interno dell'indice avviene tramite i metodi `preGetCollectionsItems`, `getCollectionsItems` e `postGetCollectionsItems`. I provider segnalano al plugin broker che sono interessati ad inserire un elemento all'interno dell'indice, indicando una priorità per uno di quei 3 metodi (se vuoi maggiori informazioni sul sistema di priorità, puoi trovarle [PluginsAPI#Priority_System qui]). Nel nostro caso, è sufficiente modificare il costruttore della classe per settare la priorità del metodo `getCollectionsItems` che andremo subito a implementare.

{{{
	function __construct() {
		$this->setPriority('getCollectionsItems');
	}
}}}

Il metodo `getCollectionsItems` prevede che un plugin che voglia inserire uno o più elementi all'interno dell'indice, deve restituire come valore di ritorno una instanza della classe `X_Page_ItemList_PItem`. Questa classe è la rappresentazione di una lista di oggetti `X_Page_Item_PItem`. Ogni singolo oggetto della classe `X_Page_Item_PItem` rappresenta un elemento della playlist. E' possibile specificare molte informazioni tramite questo oggetto (ad esempio un icona, un'immagine di anteprima, una descrizione...), ne vedremo alcuni più in dettaglio. Il sistema provvederà a convertire le informazioni incapsulate in questo oggetto in una rappresentazione consona al tipo di dispositivo che richiederà l'esplorazione.

Nel nostro caso specifico, aggiungeremo un solo elemento all'indice che avrà il compito di consentire la navigazione all'interno delle risorse di FilmStream.

{{{
	/**
	 * Add the FilmStream link inside collection index
	 * @param Zend_Controller_Action $controller
	 */
	public function getCollectionsItems(Zend_Controller_Action $controller) {
		
		X_Debug::i("Plugin triggered");
		
		$link = new X_Page_Item_PItem($this->getId(), X_Env::_('p_filmstream_collectionindex'));
		$link->setIcon('/images/filmstream/logo.png')
			->setDescription(X_Env::_('p_filmstream_collectionindex_desc'))
			->setType(X_Page_Item_PItem::TYPE_CONTAINER)
			->setLink(
				array(
					'controller' => 'browse',
					'action' => 'share',
					'p' => $this->getId(),
				), 'default', true
			);
		return new X_Page_ItemList_PItem(array($link));
	}

}}}

Tralasciando proprietà più ovvie come `setLabel` o `setDescription`, passiamo subito a spiegare il senso di metodi più particolari.

Il metodo `setType` consente di definire il tipo di elemento che verrà rappresentato dall'oggetto `X_Page_Item_PItem`. In questo caso, poichè il nostro elemento aggiunto è un contenitore di altre risorse, specifichiamo come tipo `X_Page_Item_PItem::TYPE_CONTAINER`. Altri valori possibili sono 
`X_Page_Item_PItem::TYPE_PLAYABLE` (rappresenta un elemento che può essere riprodotto), `X_Page_Item_PItem::TYPE_ELEMENT` (un elemento generico, può rappresentare qualsiasi cosa), `X_Page_Item_PItem::TYPE_REQUEST` (rappresenta un elemento che richiede una qualche interazione con l'utente per l'inserimento di valori).

Il metodo `setLink` permette di specificare la risorsa che verrà esplorata selezionando questo elemento. Specificando un array associativo, potremo specificare un insieme di parametri che verranno passati alla richiesta successiva qualora l'elemento venisse selezionato. In questo caso stiamo specificando che, nel caso di selezione, il controllo del sistema deve essere affidato al controller `BrowseController` e all'azione `shareAction`. Tutti gli altri elementi specificati nell'array verranno trattati come parametri (chiave => valore) passati direttamente all'azione. Si può passare qualsiasi valore arbitrario senza alcun genere di controllo, fatta eccezione per alcuni parametri riservati a scopi specifici.

Questa è una lista dei parametri riservati:

|| *chiave* || *nome discorsivo* || *descrizione* || *note sui valori* ||
|| p || provider || rappresenta il plugin che ha il compito di gestire la navigazione nel sistema e che ha il compito di gestire la l (location) || il suo valore è sempre uguale alla chiave di un plugin ||
|| l || location || rappresenta lo stato attuale di navigazione del sistema. Ogni provider può definirne arbitrariamente il formato e deve provvedere a codificarne il valore tramite la funzione X_Env::encode || Codificato tramite X_Env::encode ||
|| pid || pluginId || Indica la chiave di un plugin che deve gestire una funzione secondaria || è sempre uguale alla chiave di un plugin ||
|| a || activity || rappresenta una attività da eseguire || ||
|| param || parametro || rappresenta un valore arbitrario associato ad una activity || solitamente richiesto all'utente tramite interazione ||

Specificando quindi il valore di provider pari a `$this->getId()` stiamo indicando al sistema che il provider che gestirà la navigazione nel caso di selezione di questa risorsa sarà proprio questo plugin.

I valori di `action` e `controller` indicano il passaggio del sistema nella fase di navigazione. Un grafico degli stati di navigazione è disponibile [PluginsAPI#System_Architecture nell'architettura di sistema].


==Fase 6: testiamo quanto fatto finora==

Lo so, siamo ancora all'inizio. Però è il momento di cominciare a guardare qualche risultato. La fase preparatoria del `dev_cleanup.php` ci permette di poter testare in maniera agevole il plugin senza doverlo installare. Per farlo basta recarsi nella pagina delle configurazioni di vlc-shares (`http://localhost/vlc-shares-dev/public/configs`), mostrare le configurazioni avanzate e specificare all'interno della lista di plugin opzionali da caricare, la chiave del nostro plugin, in questo caso `filmstream`. Vedremo più avanti che è possibile specificare un elenco di plugin da caricare semplicemente separando ogni singola chiave con una virgola. Salviamo le modifiche (visto che ci siete, attivare il debug log e impostarne il livello su TUTTO non sarebbe una cattiva idea) e andiamo all'indice delle collezioni (il pulsante Browse nella barra superiore di vlc-shares). 

Eccolo li, il nostro nuovo fiammante pulsante per FilmStream che compare. 

https://lh5.googleusercontent.com/_U6HIkh_ODAo/TZOx70OiwiI/AAAAAAAAAGg/4kvP0N0-4EU/s800/plugin_0.5.4_tutorial_1.png


==Fase 7: prepariamo l'indice==

Come avrete sicuramente notato, cliccando sul pulsante appena creato non verrà visualizzato assolutamente nulla. E' ora di cominciare a riempire qualcosa.
La navigazione all'interno di un provider viene gestita dalla pagina `browse/shares` (`browseController::shareAction()`). Il comportamento della pagina e le interazioni con i plugin sono molto semplici:

   * in controller invoca in successione i trigger `preGetShareItems`, `getShareItems` e `postGetShareItems`. Il loro funzionamento è analogo a `getCollectionsItems`: generano oggetti di tipo `X_Page_Item_PItem` raccolti all'interno di liste di tipo `X_Page_ItemList_PItem`. Le tre liste generate dai tre trigger vengono fuse insieme per generarne una unica che conservi l'ordinamento. In questa fase verranno generati i contenuti visualizzati.
   * una volta che tutti i contenuti sono stati generati, il controller invoca per ogni contenuto il trigger `filterShareItems`. Questo trigger permette a tutti i plugin che si sono registrati di esprimere un valore booleano che ne determini un'eventuale rimozione dalla lista. Se anche solo uno dei plugin restituirà `false`, l'elemento verrà rimosso dalla lista.
   * filtrata la lista, l'ultimo passaggi di preparazione riguarda l'ordinamento dei contenuti. Il controller chiama il trigger `orderShareItems` dando in input un array di elementi `X_Page_Item_PItem` per permetterne l'ordinamento in maniera arbitraria. Nelle installazioni standard di vlc-shares è attivo un plugin di default (`X_VlcShares_Plugins_SortItems`) che si occupa proprio di ordinare gli elementi per tipo e in ordine alfabetico. Vedremo più avanti come disattivarlo nel caso in cui non volessimo questo tipo di servizio.
   * ultimata la preparazione, il controller delega le ultime operazioni ai plugin di tipo Renderer tramite `gen_afterPageBuild`: questo tipo di plugin hanno lo scopo di trasformare gli elementi generati nei passaggi precedenti, in una forma utilizzabile dal device che sta generando la richiesta della pagina (ad esempio: se si sta navigando tramite Wii sarà compito del WiimcPlxRenderer trasformarli in una playlist PLX, se tramite un browser questo sarà onere del MobileRenderer). In ogni caso non discuterò ulteriormente in questa guida le implicazioni di questo trigger visto che è un argomento che merità una trattazione separata.

Ritorniamo al nostro plugin: come avrete sicuramente inteso, l'intera navigazione all'interno dei contenuti avviene sempre in questa pagina. Per determinare la nostra posizione all'interno delle risorse e decidere quali visualizzare utilizzeremo il parametro `location`. Come già detto, il formato di questo parametro è arbitrario. Dobbiamo quindi decidere come gestirlo in base alle nostre esigente.
Durante la _Fase 2_ abbiamo pianificato come dovranno essere organizzate le nostre risorse. Partendo da li possiamo decidere il modo più idoneo per il formato della nostra `location`.

Utilizzeremo un separatore `/` per separare i parametri contenuti nella location. Non dobbiamo preoccuparci che questo possa interferire con altri parametri di vlc-shares in quanto codificando la `location` tramite `X_Env::encode()` scongiureremo proprio questo genere di eventualità.

In definitiva la nostra `location` completa verrà rappresentata in questo modo:

{{{
TIPO_RISORSA/TIPO_GRUPPO/N_PAGINA/ID_TITOLO/ID_FILMATO
}}}

Per rendere chiaro questo passaggio vi faccio qualche esempio:

{{{
film/I/2/inception/mv:12345678
}}}
Indica che stiamo visualizzando la risorsa nella categoria "film", gruppo "i", pagina "2", id elemento "inception", id filmato "mv:12345678". Questa è la location che rappresenta una URL ad un filmato. Tramite `getLocation` potremo infatti ottenere URL diretto ad un video.

{{{
film/I/inception/
}}}
Indica che stiamo visualizzando la risorsa nella categoria "film", gruppo "i", pagina "2", id elemento "inception". Questa `location` rappresenta la pagina indice dei filmati per l'elemento "inception". Il provider genererà quindi l'elenco dei filmato relativi ad "inception"

Utilizzando questa notazione possiamo sempre ottenere facilmente la pagina padre (basterà eliminare ultimo parametro della location) e capire al volo quali risorse generare (quelle in grado di impostare il parametro mancante).

Traduciamo questi concetti in codice aggiungendo due nuovi metodi alla nostra classe `X_VlcShares_Plugins_FilmStream`.

{{{
	/**
	 * Fetch resources from filmstream site
	 * @param string $provider the plugin key of the one who should handle the request
	 * @param string $location the current $location
	 * @param Zend_Controller_Action $controller the controller who handle the request
	 * @return X_Page_ItemList_PItem
	 */
	public function getShareItems($provider, $location, Zend_Controller_Action $controller) {
		// this plugin fetch resources only if it's the provider
		if ( $provider != $this->getId() ) return;
		// add an info inside the debug log so we can trace this call 
		X_Debug::i('Plugin triggered');
		// disable automatic sorting, items will be already sorted in the target site
		X_VlcShares_Plugins::broker()->unregisterPluginClass('X_VlcShares_Plugins_SortItems');
		// let's create the itemlist
		$items = new X_Page_ItemList_PItem();
		// show the requested location in the debug log
		// $location has been already decoded
		X_Debug::i("Requested location: $location");
		
		// location format:
		// resourceType/resourceGroup/page/resourceId/videoId
		
		$split = $location != '' ? @explode('/', $location, 5) : array();
		@list($resourceType, $resourceGroup, $page, $resourceId, $videoId) = $split;
		
		X_Debug::i("Exploded location: ".var_export($split, true));

		// Choose what to do based on the number of params
		// setted inside $location
		switch ( count($split) ) {
			case 5:
				// we shouldn't be here!
				// if we have 5 pieces (so even $videoId is setted)
				// we should be inside the browse/mode page
				// because the location is about a video URL
			case 4:
				// delegate to fetchVideos
				$this->_fetchVideos($items, $resourceType, $resourceGroup, $page, $resourceId);
				break;
			case 2:
				$page = 1;
			case 3:
				// delegate to fetchResources
				$this->_fetchResources($items, $resourceType, $resourceGroup, $page);
				break;
			case 1:
				// fetchGroups doesn't require any kind of network traffic
				// so it's useless to cache the results
				$this->disableCache();
				// delegate to fetchGroups
				$this->_fetchGroups($items, $resourceType);
				break;
			
			case 0:
			default: 
				// fetchTypes doesn't require any kind of network traffic
				// so it's useless to cache the results
				$this->disableCache();
				// delegate to fetchTypes
				$this->_fetchTypes($items);
			
		}
				
		
		return $items;
		
	}
	
	/**
	 * Disable cache plugin is registered and enabled
	 */
	private function disableCache() {
		
		if ( X_VlcShares_Plugins::broker()->isRegistered('cache') ) {
			$cache = X_VlcShares_Plugins::broker()->getPlugins('cache');
			if ( method_exists($cache, 'setDoNotCache') ) {
				$cache->setDoNotCache();
			}
		}
		
	}
	
}}}

Il primo metodo `getShareItems` è il nostro trigger che gestirà la navigazione. Ho deciso di strutturare il metodo in modo che il suo unico compito sia quello di analizzare il formato della `$location` e di delegare la generazione degli elementi a dei metodi privati (che aggiungeremo in seguito) in base al tipo di parametri trovati. Nei commenti in linea potete trovare informazioni specifiche su quello che succede. 

Mi soffermo semplicemente su l'analisi di quello che succede alla `$location`:

{{{
		// location format:
		// resourceType/resourceGroup/page/resourceId/videoId
		
		$split = $location != '' ? @explode('/', $location, 5) : array();
		@list($resourceType, $resourceGroup, $page, $resourceId, $videoId) = $split;
}}}

inseriamo in `$split` un array dei parametri memorizzati in `$location` (dopo averli divisi utilizzando '/' come separatore). In seguito assegnamo in base alla posizione, i valori contenuti all'interno dell'array esploso a delle variabili.

Fatto questo, andremo a valutare cosa fare in base al numero di parametri individuati:

   * se non sarà presente alcun parametro (`$location` vuota), sigificherà che dovremo visualizzare la pagina di selezione del TIPO_RISORSA
   * se sarà presente solo il TIPO_RISORSA, visualizzeremo quella di selezione di TIPO_GROUPPO
   * ...cosi via...

Dopo aver implementato il nostro trigger, dobbiamo segnalarlo al broker aggiungendo una priorità. Così come abbiamo fatto per `getCollectionsItems`, ripetiamo la procedura anche per `getShareItems`. Modifichiamo il costruttore:

{{{
	function __construct() {
		$this->setPriority('getCollectionsItems');
		$this->setPriority('getShareItems');
	}

}}}



A questo punto cerchiamo di risolvere il primo scenario: `ho appena cliccato nell'indice delle collezioni su FilmStream e quindi non ho ancora nessun parametro in $location`.

All'interno del nostro `switch`, questo scenario è rappresentato dal `case`:

{{{

			case 0:
			default: 
				// fetchTypes doesn't require any kind of network traffic
				// so it's useless to cache the results
				$this->disableCache();
				// delegate to fetchTypes
				$this->_fetchTypes($items);

}}}

Andiamo a implementare quindi `_fetchTypes($items)` come metodo privato.

{{{

	const TYPE_MOVIES = 'movies';
	const TYPE_TVSHOWS = 'tv';
	const TYPE_ANIME = 'anime';
	const TYPE_SUBBED = 'subbed';
	
	/**
	 * Fill a list of types of resoures
	 * @param X_Page_ItemList_PItem $items an empty list
	 * @return X_Page_ItemList_PItem the list filled
	 */
	private function _fetchTypes(X_Page_ItemList_PItem $items) {
		
		$types = array(
			self::TYPE_MOVIES => X_Env::_('p_filmstream_type_movies'),
			self::TYPE_TVSHOWS => X_Env::_('p_filmstream_type_tvshows'),
			self::TYPE_ANIME => X_Env::_('p_filmstream_type_anime'),
			self::TYPE_SUBBED => X_Env::_('p_filmstream_type_subbed'),
		);
		
		foreach ( $types as $typeLocParam => $typeLabel ) {
			$item = new X_Page_Item_PItem($this->getId()."-type-$typeLocParam", $typeLabel);
			$item->setIcon('/images/icons/folder_32.png')
				->setType(X_Page_Item_PItem::TYPE_CONTAINER)
				->setCustom(__CLASS__.':location', "$typeLocParam")
				->setDescription(APPLICATION_ENV == 'development' ? "$typeLocParam" : null)
				->setLink(array(
					'l'	=>	X_Env::encode("$typeLocParam")
				), 'default', false);
				
			$items->append($item);
		}
	}
}}}

Quello che fa la funzione è piuttosto semplice: crea per ogni elemento inserito all'interno dell'array `$types` un nuovo elemento, usando la chiave `$typeLocParam` come parametro della `location` e il valore `$typeLabel` come etichetta per l'elemento.

*Importante*: osservate come il parametro `l` (`location`) venga codificato tramite `X_Env::encode`.

Possiamo adesso testare quanto aggiunto cliccando su FilmStream all'interno della lista delle collezioni.


https://lh5.googleusercontent.com/_U6HIkh_ODAo/TZRGTBtUqXI/AAAAAAAAAGw/8cRDq48YYtI/s800/plugin_0.5.4_tutorial_2.png


==Fase 8: preparamo la selezione dei gruppi==

Come visto nella fase preparatoria e in quella precendente a questa, dopo l'indice principale è la volta di gestire lo scenario in cui l'utente ha selezionato uno dei 4 tipi visualizzati.
Lo scenario è abbastanza semplice: quello che dobbiamo fare è visualizzare una lista di gruppi di risorse (faremo una divisione per lettere e aggiungeremo anche il gruppo "Novità" in testa).

Questo caso corrisponde a quello in cui nella `$location` venga specificato un solo parametro:

{{{

			case 1:
				// fetchGroups doesn't require any kind of network traffic
				// so it's useless to cache the results
				$this->disableCache();
				// delegate to fetchGroups
				$this->_fetchGroups($items, $resourceType);
				break;


}}}


Andiamo quindi a implementare il metodo privato `_fetchGroups($items, $resourceType)` passando come parametri l'elenco da riemprire e (tramite `$resourceType`) il tipo attualmente selezionato.

{{{

	/**
	 * Fill a list of groups of resoures by type
	 * @param X_Page_ItemList_PItem $items an empty list
	 * @param string $resourceType the resource type selected
	 * @return X_Page_ItemList_PItem the list filled
	 */
	private function _fetchGroups(X_Page_ItemList_PItem $items, $resourceType) {

		if ( $resourceType == self::TYPE_MOVIES ) {
			$groups = 'new,0-9,a-b,c-d,e-f,g-h-j-k,i-l,m-n,o-p,q-r-s,t-u-v,w-x-y-z';
		} else {
			$groups = 'new,'.strtoupper('0-9,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z');
		}
		$groups = explode(',', $groups);
		
		foreach ( $groups as $group ) {
			$item = new X_Page_Item_PItem($this->getId()."-$resourceType-$group", ($group == 'new' ? X_Env::_('p_filmstream_group_new') : strtoupper($group)));
			$item->setIcon('/images/icons/folder_32.png')
				->setType(X_Page_Item_PItem::TYPE_CONTAINER)
				->setCustom(__CLASS__.':location', "$resourceType/$group")
				->setDescription(APPLICATION_ENV == 'development' ? "$resourceType/$group" : null)
				->setLink(array(
					'l'	=>	X_Env::encode("$resourceType/$group")
				), 'default', false);
				
			$items->append($item);
		}
	}

}}}

Questo metodo funziona più o meno come il `_fetchTypes` con una piccola differenza: il tipo di gruppi da visualizzare viene deciso in base al tipo di `$resourceType` che l'utente ha selezionato.

Sul sito FilmStream nello specifico i film vengono divisi in gruppi alfabetici di più lettere, mentre gli altri tipi di risorse sono suddivisi in gruppi di singole lettere (anche se vengono comunque tutti mostrati nella spessa pagina. In realtà solo per i film è stata disposta una pagina per ogni gruppo alfabetico). Questo richiede di effettuare un distinguo, quello che fa il primo `if`.

Altra nota importante riguarda l'uso della `$location`. Come vediamo, il parametro `l` viene compilato inserendo la vecchia selezione e la nuova in successione (`$resourceType/$group`) per ogni singolo gruppo. Questo ci permetterà di passare al caso successivo (quello a 2 parametri) cliccando uno degli elementi generati qui.

Possiamo provare le modifiche selezionando uno dei tipi.

https://lh6.googleusercontent.com/_U6HIkh_ODAo/TZRP6sDXPKI/AAAAAAAAAG0/FfxxkfxQlTc/s800/plugin_0.5.4_tutorial_3.png


==Fase 9: leggiamo i titoli dal sito==

Arrivati a questo punto abbiamo a disposizione (in quanto selezionato dall'utente e quindi presente nella `$location`) il tipo e il gruppo di risorse al quale siamo interessati. Non ci rimane che leggere dal sito i titoli delle risorse
Questa fase riguarda il `case` a 2 e 3 parametri. Li gestiremo insieme in quanto sul sito non è presente una divisione dei contenuti in più pagine per categoria, quindi il caso a 2 parametri (cioè quello in cui il numero di pagina non è selezionato) verrà considerato come se il numero di pagina indicato sia 1.

{{{

			case 2:
				$page = 1;
			case 3:
				// delegate to fetchResources
				$this->_fetchResources($items, $resourceType, $resourceGroup, $page);
				break;

}}}